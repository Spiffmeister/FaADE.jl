

struct prob
    RHS             :: Function
    boundary_left   :: Symbol
    boundary_right  :: Symbol
    boundary        :: Union{Vector{Float64},Function}
    order           :: Int64
    k               :: Union{Vector{Float64},Float64}
end

mutable struct solution
    u       :: Array{Float64}
    x       :: Array{Float64}
    Œîx      :: Float64
    n       :: Int64
    t_f     :: Float64
    Œît      :: Float64
    solver  :: Symbol

    function solution(u‚ÇÄ,x,Œîx,t_f,Œît,solver)
        N = ceil(Int64,t_f/Œît)
        n = length(x)

        u = zeros(Float64,n,N)
        u[:,1] = u‚ÇÄ(x)

        new(u,x,Œîx,n,t_f,Œît,solver)
    end
end

struct grid
    x   :: Array{Float64}
    Œîx  :: Float64
    n   :: Int64

    function grid(ùíü,n)
        Œîx = (ùíü[2] - ùíü[1])/(n-1)
        x = collect(range(ùíü[1],ùíü[2],step=Œîx))
        new(x,Œîx,n)
    end
end

"""
    time_solver(PDE::Function,u‚ÇÄ::Function,n::Int64,x::Vector{Float64},Œîx::Float64,t_f::Float64,Œît::Float64,k::Vector{Float64},boundary::Function,boundary_left::Symbol;boundary_right::Symbol=boundary_left,method::Symbol=:euler,order::Int64=2)
"""
function time_solver(PDE::Function,u‚ÇÄ::Function,n::Int64,x::Vector{Float64},Œîx::Float64,t_f::Float64,Œît::Float64,k::Vector{Float64},boundary::Function,boundary_left::Symbol;
    boundary_right::Symbol=boundary_left,method::Symbol=:euler,order::Int64=2,Œ±::Float64=1.5,tol::Float64=1e-5,maxIT::Int64=-1,warnings::Bool=false)
    #===== 1D TIME SOLVER =====#

    # Initialise solution
    soln = solution(u‚ÇÄ,x,Œîx,t_f,Œît,method)
    # Get the length of the time array
    N = ceil(Int64,t_f/Œît)

    if method != :cgie # Not using conjugate gradient
        function RHS(u‚Çì‚Çì,u,n,x,Œîx,t,Œît,k,g)
            # Combines the PDE and SATs (forcing term included)
            u‚Çì‚Çì = PDE(u‚Çì‚Çì,u,n,x,Œîx,t,Œît,k,order=order)

            if boundary_left != :Periodic
                u‚Çì‚Çì[1:order] .+= SAT_left(boundary_left,u,Œîx,g(t),c=k,order=order)
                u‚Çì‚Çì[end-order+1:end] .+= SAT_right(boundary_right,u,Œîx,g(t),c=k,order=order)
            else
                SAT‚Çó,SAT·µ£ = SAT_Periodic(u,Œîx,k,order=order)
                u‚Çì‚Çì[1:order] += SAT‚Çó
                u‚Çì‚Çì[end-order+1:end] += SAT·µ£
            end
            return u‚Çì‚Çì
        end
    end

    if method == :euler
        # Eulers method
        for i = 1:N-1
            t = i*Œît
            soln.u[:,i+1] = forward_euler(soln.u[:,i+1],soln.u[:,i],RHS,n,Œîx,Œît,k,t,x,boundary)
        end
    elseif method == :rk4
        # Runge-Kutta 4
        for i = 1:N-1
            t = i*Œît
            soln.u[:,i+1] = RK4(soln.u[:,i+1],soln.u[:,i],RHS,n,Œîx,Œît,k,t,x,boundary)
        end
    elseif method == :impliciteuler
        # Implicit euler
        if maxIT == -1
            maxIT = 100
        end
        for i = 1:N-1
            t = i*Œît
            soln.u[:,i+1] = implicit_euler(soln.u[:,i+1],soln.u[:,i],RHS,n,Œîx,Œît,k,t,x,boundary,Œ±=Œ±,maxIT=maxIT)
        end
    elseif method == :cgie
        if maxIT == -1
            maxIT = 15
        end
        function cgRHS(u‚Çì‚Çì,u,n,x,Œîx,t,Œît,k,g)
            u‚Çì‚Çì = PDE(u‚Çì‚Çì,u,n,x,Œîx,t,Œît,k,order=order)
            SAT‚Çó, = SAT_left(boundary_left,u,Œîx,g(t),order=order,seperate_forcing=true)
            SAT·µ£, = SAT_right(boundary_left,u,Œîx,g(t),order=order,seperate_forcing=true)
            u‚Çì‚Çì[1:order] += SAT‚Çó
            u‚Çì‚Çì[end-order+1:end] += SAT·µ£
            return u‚Çì‚Çì
        end

        if order == 2
            H = diagm(ones(length(x)))
            H[1,1] = H[end,end] = 0.5
        elseif order == 4
            H = diagm(ones(length(x)))
            H[1,1] = H[end,end] = 0.5
            H[2,2] = H[end-1,end-1] = 0.5
            H[3,3] = H[end-2,end-2] = 0.5
        elseif order == 6
            H = diagm(ones(length(x)))
        end
        H = Œîx*H

        for i = 1:N-1
            t = i*Œît
            u‚±º = soln.u[:,i]
            SAT‚Çó,F‚Çó = SAT_left(boundary_left,u‚±º,Œîx,boundary(t),order=order,seperate_forcing=true)
            SAT·µ£,F·µ£ = SAT_right(boundary_right,u‚±º,Œîx,boundary(t),order=order,seperate_forcing=true)
            u‚±º[1:order] += Œît*F‚Çó
            u‚±º[end-order+1:end] += Œît*F·µ£
            soln.u[:,i+1] = conj_grad(u‚±º,u‚±º,cgRHS,n,Œîx,Œît,k,t,x,H,boundary;tol=1e-5,maxIT=20)
        end
    else
        error("Method must be :euler, :rk4, :impliciteuler or :cgie")
    end

    return soln
end

function time_solver(PDE::Function,u‚ÇÄ::Function,nx::Int64,ny::Int64,Œîx::Float64,Œîy::Float64,x::Vector{Float64},y::Vector{Float64},t_f::Float64,Œît::Float64,kx::Matrix{Float64},ky::Matrix{Float64},gx,gy,boundary_x::Symbol,boundary_y::Symbol;method=:euler,order_x=2,order_y=order_x)
    #===== 2D TIME SOLVER =====#

    # Preallocate and set initial
    N = ceil(Int64,t_f/Œît)
    u = zeros(Float64,nx,ny,N)
    for i = 1:nx
        for j = 1:ny
            u[i,j,1] = u‚ÇÄ(x[i],y[j])
        end
    end
    u[:,1,:]  .= gx(0)[1]
    u[:,end,1].= gx(0)[end]
    u[1,:,:]  .= gy(0)[1]
    u[end,:,:].= gy(0)[end]


    if method != :cgie
        function RHS(u‚Çì‚Çì,u,nx,ny,x,y,Œîx,Œîy,t,Œît,kx,ky,gx,gy)
            u‚Çì‚Çì = PDE(u‚Çì‚Çì,u,nx,ny,x,y,Œîx,Œîy,t,Œît,kx,ky,order_x=order_x,order_y=order_y)
            for i = 1:ny #x boundaries
                u‚Çì‚Çì[i,1:order_x] += SAT_left(boundary_x,u[i,:],Œîx,gx(t),c=kx[i,:],order=order_x)
                u‚Çì‚Çì[i,end-order_x+1:end] += SAT_right(boundary_x,u[i,:],Œîx,gx(t),c=kx[i,:],order=order_x)
            end
            for i = 1:nx
                u‚Çì‚Çì[1:order_y,i] += SAT_left(boundary_y,u[:,i],Œîy,gy(t),c=ky[:,i],order=order_y)
                u‚Çì‚Çì[end-order_y+1:end,i] += SAT_right(boundary_y,u[:,i],Œîy,gy(t),c=ky[:,i],order=order_y)
            end
            return u‚Çì‚Çì
        end
    end
    
    if method == :euler
        for i = 1:N-1
            t = i*Œît
            u[:,:,i+1] = forward_euler(u[:,:,i+1],u[:,:,i],RHS,nx,ny,x,y,Œîx,Œîy,t,Œît,kx,ky,gx,gy)
        end
    elseif method == :cgie
        maxIT == -1 ? maxIT = 15 : nothing

        function cgRHS(u‚Çì‚Çì,u,nx,ny,x,y,Œîx,Œîy,t,Œît,kx,ky,gx,gy)
            u‚Çì‚Çì = PDE(u‚Çì‚Çì,u,nx,ny,x,y,Œîx,Œîy,t,Œît,kx,ky,gx,gy,order_x=order_x,order_y=order_y)
            for i = 1:ny
                SAT‚Çó, = SAT_left(boundary_x,u[i,:],Œîx,gx(t),c=kx[i,:],order=order_x)
                SAT·µ£, = SAT_left(boundary_x,u[i,:],Œîx,gx(t),c=kx[i,:],order=order_x)
                u‚Çì‚Çì[i,1:order_x] += SAT‚Çó
                u‚Çì‚Çì[i,end-order_x+1:end] += SAT·µ£
            end
            for i = 1:nx
                SAT‚Çó, = SAT_left(boundary_y,u[:,i],Œîy,gy(t),c=ky[:,i],order=order_y)
                SAT·µ£, = SAT_left(boundary_y,u[:,i],Œîy,gy(t),c=ky[:,i],order=order_y)
                u‚Çì‚Çì[1:order_y,i] += SAT‚Çó
                u‚Çì‚Çì[end-order_y+1:end,i] += SAT·µ£
            end
            return u‚Çì‚Çì
        end

        if order == 2
            Hx = ones(nx)
            Hy = ones(ny)
            Hx[1] = Hx[end] = 0.5
            Hy[1] = Hy[end] = 0.5
        else
            error("order must be 2 ATM")
        end
        Hx *= Œîx
        Hy *= Œîy
        for i = 1:N-1
            t = i*Œît
            u‚±º = u[:,:,i]
            u[:,:,i+1] = conj_grad(u‚±º,u‚±º,RHS,nx,ny,x,y,Œîx,Œîy,t,Œît,kx,ky,boundary_x,boundary_y,Hx,Hy,tol=1e-5,maxIT=20)
        end
    end
    return u
end



#= EXPLICIT METHODS =#
function forward_euler(u‚Çô::Vector,u‚Çí::Vector,RHS::Function,n::Int,Œîx::Float64,Œît::Float64,k::Vector,t::Float64,x::Vector,g)
    # Simple forward euler method
    u‚Çô = u‚Çí + Œît*RHS(u‚Çô,u‚Çí,n,x,Œîx,t,Œît,k,g)
    return u‚Çô
end
function forward_euler(u‚Çô::Matrix,u‚Çí::Matrix,RHS::Function,nx::Int,ny::Int,x,y,Œîx::Float64,Œîy::Float64,t::Float64,Œît::Float64,kx::Matrix,ky::Matrix,gx,gy)
    # Simple forward euler method
    u‚Çô = u‚Çí + Œît*RHS(u‚Çô,u‚Çí,nx,ny,x,y,Œîx,Œîy,t,Œît,kx,ky,gx,gy)
    return u‚Çô
end

function RK4(u‚Çô::Vector,u‚Çí::Vector,RHS::Function,n::Int,Œîx::Float64,Œît::Float64,k::Vector,t::Float64,x::Vector,boundary)
    k1 = RHS(u‚Çô,u‚Çí        ,n,x,Œîx,t,Œît,k,       boundary)
    k2 = RHS(u‚Çô,u‚Çí+Œît/2*k1,n,x,Œîx,t+0.5Œît,Œît,k, boundary)
    k3 = RHS(u‚Çô,u‚Çí+Œît/2*k2,n,x,Œîx,t+0.5Œît,Œît,k, boundary)
    k4 = RHS(u‚Çô,u‚Çí+Œît*k3  ,n,x,Œîx,t+Œît,Œît,k,    boundary)
    u‚Çô = u‚Çí + Œît/6 * (k1 + 2k2 + 2k3 + k4)
    return u‚Çô
end

#= IMPLICIT METHODS =#
function implicit_euler(u‚Çô::Vector,u‚Çí::Vector,RHS::Function,n::Int,Œîx::Float64,Œît::Float64,k::Vector,t::Float64,x::Vector,boundary;maxIT::Int=100,Œ±::Float64=1.5)
    u‚±º = u‚Çí
    for j = 1:maxIT
        u‚±º = u‚±º - Œ± * Œît * (u‚±º - u‚Çí - Œît*RHS(u‚Çô,u‚±º,n,x,Œîx,t,Œît,k,boundary))
    end
    u‚±º = u‚Çí + Œît*RHS(u‚Çô,u‚±º,n,x,Œîx,t,Œît,k,boundary)
    return u‚±º
end


#= SUPPORT =#
function A(u‚±º,PDE::Function,n,Œîx,x,Œît,t,k,g)
    # tmp can be any vector of length(u‚±º)
    tmp = zeros(length(u‚±º))
    tmp = u‚±º - Œît*PDE(tmp,u‚±º,n,x,Œîx,t,Œît,k,g)
    return tmp
end
function A(u‚±º,PDE::Function,nx,ny,x,y,Œîx,Œîy,t,Œît,kx,ky,gx,gy)
    # A for 2D arrays
    tmp = zeros(size(u‚±º))
    tmp -= Œît*PDE(tmp,u‚±º,nx,ny,x,y,Œîx,Œîy,t,Œît,kx,ky,gx,gy)
    return tmp
end


function innerH(u::Vector,H::Array,v::Vector)
    # H inner product for 1D problems
    return dot(u,H*v)
end
function innerH(u::Matrix,Hx::Vector,Hy::Vector,v::Matrix)
    # H inner product for 2D problems
    nx,ny = size(u)
    tmp = 0
    for i = 1:nx
        for j = 1:ny
            tmp += u[i,j]*v[i,j]*Hx[i]*Hy[j]
        end
    end
    return tmp
end


function conj_grad(b::Vector,u‚±º::Vector,RHS::Function,n::Int,Œîx::Float64,Œît::Float64,k::Vector,t::Float64,x::Vector,H::Array,boundary;tol::Float64=1e-5,maxIT::Int=10,warnings=false)
    # VECTOR FORM
    x‚Çñ = zeros(length(b)) #Initial guess
    r‚Çñ = A(u‚±º,RHS,n,Œîx,x,Œît,t,k,boundary) - b
    d‚Çñ = -r‚Çñ
    i = 0
    rnorm = sqrt(innerH(r‚Çñ,H,r‚Çñ))
    while (rnorm > tol) & (i < maxIT)
        Ad‚Çñ = A(d‚Çñ,RHS,n,Œîx,x,Œît,t,k,boundary)
        d‚ÇñAd‚Çñ = innerH(d‚Çñ,H,Ad‚Çñ)
        Œ±‚Çñ = -innerH(r‚Çñ,H,d‚Çñ)/d‚ÇñAd‚Çñ
        x‚Çñ = x‚Çñ + Œ±‚Çñ*d‚Çñ
        r‚Çñ = A(x‚Çñ,RHS,n,Œîx,x,Œît,t,k,boundary) - b
        Œ≤‚Çñ = innerH(r‚Çñ,H,A(r‚Çñ,RHS,n,Œîx,x,Œît,t,k,boundary))/d‚ÇñAd‚Çñ
        d‚Çñ = - r‚Çñ + Œ≤‚Çñ*d‚Çñ
        rnorm = sqrt(innerH(r‚Çñ,H,r‚Çñ))
        # rnorm = norm(r‚Çñ)
        i += 1
    end
    if (norm(r‚Çñ)>tol) & warnings
        warnstr = string("CG did not converge at t=",t)
        @warn warnstr
    end
    return x‚Çñ
end
function conj_grad(b::Matrix,u‚±º::Matrix,RHS::Function,nx::Int,ny::Int,x::Vector,y::Vector,Œîx::Float64,Œîy::Float64,t::Float64,Œît::Float64,kx,ky,Hx,Hy;tol=1e-5,maxIT=10,warnings=false)
    # MATRIX FORM
    x‚Çñ = zeros(length(b)) #Initial guess
    r‚Çñ = A(u‚±º,RHS,nx,ny,x,y,Œîx,Œîy,t,Œît,kx,ky,gx,gy) - b
    d‚Çñ = -r‚Çñ
    i = 0
    rnorm = sqrt(innerH(r‚Çñ,Hx,Hy,r‚Çñ))
    while (rnorm > tol) & (i < maxIT)
        Ad‚Çñ = A(d‚Çñ,RHS,nx,ny,x,y,Œîx,Œîy,t,Œît,kx,ky,gx,gy)
        d‚ÇñAd‚Çñ = innerH(d‚Çñ,H,Ad‚Çñ)
        Œ±‚Çñ = -innerH(r‚Çñ,H,d‚Çñ)/d‚ÇñAd‚Çñ
        x‚Çñ = x‚Çñ + Œ±‚Çñ*d‚Çñ
        r‚Çñ = A(x‚Çñ,RHS,nx,ny,x,y,Œîx,Œîy,t,Œît,kx,ky,gx,gy) - b
        Œ≤‚Çñ = innerH(r‚Çñ,H,A(r‚Çñ,RHS,nx,ny,x,y,Œîx,Œîy,t,Œît,kx,ky,gx,gy))/d‚ÇñAd‚Çñ
        d‚Çñ = - r‚Çñ + Œ≤‚Çñ*d‚Çñ
        rnorm = sqrt(innerH(r‚Çñ,Hx,Hy,r‚Çñ))
        i += 1
    end
    if (norm(r‚Çñ)>tol) & warnings
        warnstr = string("CG did not converge at t=",t)
        @warn warnstr
    end
    return x‚Çñ
end


