var documenterSearchIndex = {"docs":
[{"location":"tutorials/example2D.html#2D-example","page":"2D example","title":"2D example","text":"","category":"section"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"The 2D code works similarly to the 1D version, with a few different function calls.","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"using FaADE","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"This example gives a 1D solution to a 2D problem.","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"We'll solve the 2D heat equation.","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"      fracpartial upartial t = KfracDelta u","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"with boundary conditions","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"      u(0t) = 0 qquad partial_x u(1t) = 0","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"and initial condition","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"      u(x0) = expleft(frac-(x-05)^2002right)","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"We first need to create a domain to solve the PDE using Grid2D","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"𝒟x = [0.0,1.0]\n𝒟y = [0.0,1.0]\nnx = ny = 41\ngrid = Grid2D(𝒟x,𝒟y,nx,ny)","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"The initial condition","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"u₀(x,y) = exp(-((x-0.5)^2 + (y-0.5)^2) / 0.02)","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"Set the FD order to 2,","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"order = 2","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"The boundary conditions are defined by creating SimultanousApproximationTerm objects, which will then be fed to the PDE structure","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"BoundaryLeft    = SAT_Dirichlet((X,t)->0.0,grid.Δx, Left, order)\nBoundaryRight   = SAT_Neumann((X,t)->0.0, grid.Δx, Right, order)\nBoundaryUp      = SAT_Periodic(grid.Δy, Up, order)\nBoundaryDown    = SAT_Periodic(grid.Δy, Down, order)\n\nBCs = (BoundaryLeft,BoundaryRight,BoundaryUp,BoundaryDown)","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"The 2 input to the periodic boundary ensures it is along the y-axis.","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"Set the diffusion in x and y directions to 1","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"Kx = Ky = 1.0","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"Now we can create a Problem2D object to pass to the solver,","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"P = Problem2D(order,u₀,Kx,Ky,grid,BCs)","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"Lastly before solving we define our time step and simulation time,","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"Δt = 0.01grid.Δx;\nt_f = 200Δt;\nnothing #hide","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"Finally we call the solver (currently not working with Documenter.jl)","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"soln = solve(P,grid,Δt,t_f)","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"The solver ourputs a solution data structure, with everything packaged in that we would need to reconstruct the problem from the final state if we wanted to restart.","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"No visualisation routines are written at the moment but we imported the Plots.jl package earlier so we'll use that","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"using Plots\nsurface(grid.gridx, grid.gridy, soln.u[2])","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"","category":"page"},{"location":"tutorials/example2D.html","page":"2D example","title":"2D example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"UserInteraction.html#User-interaction","page":"Problems","title":"User interaction","text":"","category":"section"},{"location":"UserInteraction.html#FaADE.Inputs","page":"Problems","title":"FaADE.Inputs","text":"Inputs\n\nModule for interfacing with FaADE.jl and creating problem objects to run the code on.\n\n\n\n\n\n","category":"module"},{"location":"UserInteraction.html#User-interaction-2","page":"Problems","title":"User interaction","text":"","category":"section"},{"location":"UserInteraction.html#FaADE.Inputs.PDEProblem","page":"Problems","title":"FaADE.Inputs.PDEProblem","text":"PDEProblem{dtype,DIMS}\n\nAbstract type for PDEProblemND structs.\n\nsee Problem1D and Problem2D\n\n\n\n\n\n","category":"type"},{"location":"UserInteraction.html#FaADE.Inputs.Problem1D","page":"Problems","title":"FaADE.Inputs.Problem1D","text":"Problem1D{TT      <: Real,\nDIMS,\nDCT,\nST      <: SourceTerm,\nSATB    <: Union{Dict,Tuple},\nPART} <: PDEProblem{TT,DIMS}\n\nStruct for one dimensional problems\n\n\n\n\n\n","category":"type"},{"location":"UserInteraction.html#FaADE.Inputs.Problem1D-Union{Tuple{DIMS}, Tuple{TT}, Tuple{Integer, Any, Any, FaADE.Grid.GridType{TT, DIMS}, Any}} where {TT, DIMS}","page":"Problems","title":"FaADE.Inputs.Problem1D","text":"Problem1D(order::Integer,u₀,K,G::GridType{TT,DIMS},BCs,S,Par) where {TT,DIMS}\n\nRequired arguments:\n\norder: order of the solver to be used\nu₀: Initial condition\nK: Diffusion coefficient\nG: one dimensional Grid1D or GridMultiBlock\nBCs: Tuple of boundary conditions (see SATs)\n\n\n\n\n\n","category":"method"},{"location":"UserInteraction.html#FaADE.Inputs.Problem2D","page":"Problems","title":"FaADE.Inputs.Problem2D","text":"Problem2D{TT      <: Real,\n    DIM,\n    DCT,\n    ST      <: SourceTerm,\n    SATB    <: Union{Dict,Tuple},\n    PART} <: PDEProblem{TT,DIM}\n\nStruct for two dimensional problems\n\n\n\n\n\n","category":"type"},{"location":"UserInteraction.html#FaADE.Inputs.Problem2D-Union{Tuple{DIM}, Tuple{TT}, Tuple{Integer, Any, Any, Any, FaADE.Grid.GridType{TT, DIM}, Any}} where {TT, DIM}","page":"Problems","title":"FaADE.Inputs.Problem2D","text":"Problem2D(order::Integer,u₀,Kx,Ky,G::GridType{TT,DIM},BCs,S,Par) where {TT,DIM}\n\nRequired arguments:\n\norder: order of the solver to be used\nu₀: Initial condition\nKx: Diffusion coefficient in x\nKy: Diffusion coefficient in y\nG: one dimensional Grid2D or GridMultiBlock\nBCs: Tuple of boundary conditions (see SATs)\n\n\n\n\n\n","category":"method"},{"location":"tutorials/example2Dparallel.html#2D-with-parallel-map","page":"2D with parallel map","title":"2D with parallel map","text":"","category":"section"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"For this example we will solve the head equation with a mangetic field aligned with the grid","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"  mathbfB = (001)","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"In this case we expect the parallel operator to do nothing since mathbfP_f=mathbfP_b=I","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"using FaADE","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"For this we'll solve the field aligned equation is","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"  fracpartial upartial t = kappa_perp nabla_perp^2 u + mathcalP_parallel u","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"with Dirichlet boundaries in x","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"      u(0yt) = 0 qquad partial_x u(1yt) = 0","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"periodic in y, and initial condition","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"      u(x0) = expleft(frac-(x-05)^2002right)","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"We first need to create a domain to solve the PDE using Grid2D","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"𝒟x = [0.0,1.0]\n𝒟y = [0.0,1.0]\nnx = ny = 21\ngrid = Grid2D(𝒟x,𝒟y,nx,ny)","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"The initial condition is","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"u₀(x,y) = exp(-((x-0.5)^2 + (y-0.5)^2) / 0.02)","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"Set the FD order to 2,","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"order = 2","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"The boundary conditions are defined by creating SimultanousApproximationTerm objects, which will then be fed to the PDE structure","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"BoundaryLeft = SAT_Dirichlet((X,t)->0.0,grid.Δx, Left, order)\nBoundaryRight= SAT_Neumann((X,t)->0.0, grid.Δx, Right, order)\nBoundaryUp   = SAT_Periodic(grid.Δy, Up, order)\nBoundaryDown = SAT_Periodic(grid.Δy, Down, order)\n\nBCs = (BoundaryLeft,BoundaryRight,BoundaryUp,BoundaryDown)","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"The 2 input to the periodic boundary ensures it is along the y-axis.","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"Set the diffusion in x and y directions to 1","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"Kx = Ky = 1.0","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"The parallel penalty function can be generated by providing the code the ODE for magnetic field lines. In this case we'll just as a magnetic field that does nothing,","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"function Bfield(X,x,p,t)\n    X[2] = 0.0\n    X[1] = 0.0\nend","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"Assuming a 2pi periodicity then we can construct a parallel grid object with construct_grid, then generate the ParallelData for passing to the problem object,","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"PGrid = construct_grid(Bfield,grid,[-2π,2π])\nPData = ParallelData(PGrid,grid,order,κ=1.0)","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"Lastly before solving we define our time step and simulation time,","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"Δt = 0.01grid.Δx;\nt_f = 100Δt;\nnothing #hide","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"Now we can create a Problem2D object to pass to the solver,","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"P = Problem2D(order,u₀,Kx,Ky,grid,BCs,parallel=PData)","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"Finally we call the solver","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"soln = solve(P,grid,Δt,t_f)","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"We can now plot the solution","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"using Plots\n\nsurface(grid.gridx, grid.gridy ,soln.u[2])","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"","category":"page"},{"location":"tutorials/example2Dparallel.html","page":"2D with parallel map","title":"2D with parallel map","text":"This page was generated using Literate.jl.","category":"page"},{"location":"solvers.html#Time-Integration","page":"Solvers","title":"Time Integration","text":"","category":"section"},{"location":"solvers.html#FaADE.solvers.solve","page":"Solvers","title":"FaADE.solvers.solve","text":"solve\n\nSolve the 1D or 2D PDE on the given grid.\n\n\n\n\n\n","category":"function"},{"location":"Grid.html#Grid.md","page":"Grids","title":"Grid.md","text":"","category":"section"},{"location":"Grid.html#FaADE.Grid","page":"Grids","title":"FaADE.Grid","text":"Grid\n\nSubmodule containing the grid data structure and functions.\n\n\n\n\n\n","category":"module"},{"location":"Grid.html","page":"Grids","title":"Grids","text":"One thing to note if editing code is that the Grid.jl module has its own internal copy of first derivative operators for constructing curvilinear coordinates.","category":"page"},{"location":"Grid.html#1D-Problems","page":"Grids","title":"1D Problems","text":"","category":"section"},{"location":"Grid.html#FaADE.Grid.Grid1D","page":"Grids","title":"FaADE.Grid.Grid1D","text":"Grid1D{TT<:Real,MET<:MetricType,GT<:Vector{TT},DT<:Union{Real,Vector{TT}}} <: LocalGridType{TT,1,MET}\n\nGrid data structure for 1 dimensional problems.\n\nConstructors:\n\nGrid1D(𝒟::Vector{TT},n::Integer) where TT\nGrid1D(𝒟::Vector{TT}) where TT\n\nGrid points can be accessed as if the grid object is an array;\n\nG = Grid2D([0.0,0.5],[0.0,1.0],5,5)\nG[1]\n\nInputs:\n\nVector of domain boundaries [x_0,x_N]\nNumber of grid points.\n\nReturns:\n\nStruct for 1D grid object containing vector of grid points, Delta x and n.\n\n\n\n\n\n","category":"type"},{"location":"Grid.html#2D","page":"Grids","title":"2D","text":"","category":"section"},{"location":"Grid.html#FaADE.Grid.Grid2D","page":"Grids","title":"FaADE.Grid.Grid2D","text":"Grid2D{TT,MET<:MetricType,GT<:AbstractArray{TT}} <: LocalGridType{TT,2,MET}\n\nGrid data structure for 2 dimensional problems.\n\nGrid points can be accessed as if the grid object is an array;\n\nG = Grid2D([0.0,0.5],[0.0,1.0],5,5)\nG[1,1]\n\nInputs:\n\nDomain boundaries in x\nDomain boundaries in y\nNumber of nodes in x\nNumber of nodes in y\n\nReturns:\n\nStruct for 2D grid object containing grid points in x and y, Delta x and Delta y, and n_x and n_y.\n\n\n\n\n\n","category":"type"},{"location":"Grid.html#Multiblock-grids","page":"Grids","title":"Multiblock grids","text":"","category":"section"},{"location":"Grid.html","page":"Grids","title":"Grids","text":"Solvers for these methods are not implemented yet (SATs required)","category":"page"},{"location":"Grid.html","page":"Grids","title":"Grids","text":"The following is used for constructing multiblock problems. ","category":"page"},{"location":"Grid.html#FaADE.Grid.GridMultiBlock","page":"Grids","title":"FaADE.Grid.GridMultiBlock","text":"GridMultiBlock{TT,DIM,MET,TG,TJ,IT} <: GridType{TT,DIM,MET}\n\nGrid data for multiblock problems\n\nGrabbing a particular subgrid can be done by G.Grids[i] which indexes in the order the grids are given.  Indexing can be performed by G[i] for 1D or G[i,j] for 2D multiblock problems. GridMultiBlock.Joint contains the information on how to connect grids. If periodic boundary conditions are being used, do not specify the joint across that boundary.\n\nExample grid creation,\n\n    D1  = Grid2D([0.0,0.5],[0.0,1.0],5,5)\n    D2  = Grid2D([0.5,1.0],[0.0,1.0],5,5)\n    D3  = Grid2D([1.0,1.5],[0.0,1.0],5,5)\n\n    glayout = ([(2,Right)],\n                [(1,Left),(3,Right)],\n                [(2,Left)])\n\n    G = GridMultiBlock((D1,D2,D3),glayout)\n\n\n\n\n\n","category":"type"},{"location":"Grid.html#Curvilinear-grid-generation","page":"Grids","title":"Curvilinear grid generation","text":"","category":"section"},{"location":"Grid.html","page":"Grids","title":"Grids","text":"The meshgrid function can be used to generate domains in curvilinear coordinates.","category":"page"},{"location":"Grid.html#FaADE.Grid.meshgrid","page":"Grids","title":"FaADE.Grid.meshgrid","text":"Generates the 2D grid of nx and ny points in a domain given a set of functions which bound a domain.\n\n\n\n\n\nmeshgrid(cbottom::Function,cleft::Function,cright::Function,ctop::Function,nx::Int,ny::Int)\n\nConstruct a grid of nx by ny points in a domain bounded by the functions cbottom, cleft, cright, and ctop.\n\n\n\n\n\nmeshgrid(𝒟x::Vector{TT},𝒟y::Vector{TT}) where TT\n\nGenerate matrix of coordinates from vectors of coordinates this is useful for packed grids.\n\n\n\n\n\nmeshgrid(cinner::Function,couter::Function,nx,ny)\n\nMeshgrid for annular domains where the inner and outer boundaries are parameterised boundaries\n\n\n\n\n\nmeshgrid(inner::Torus,outer::Torus,ζ,nr,nθ)\n\nTake two tori and generate a meshgrid between them at a given toroidal angle ζ with nr radial points and nθ poloidal points.\n\nSee also: Torus\n\n\n\n\n\n","category":"function"},{"location":"Grid.html#Toroidal-surfaces","page":"Grids","title":"Toroidal surfaces","text":"","category":"section"},{"location":"Grid.html","page":"Grids","title":"Grids","text":"For generating meshgrid functions in an annulus one can use the following commands to generate two torii.","category":"page"},{"location":"Grid.html#FaADE.Grid.Torus","page":"Grids","title":"FaADE.Grid.Torus","text":"Torus{TT}\n\nRepresents a torus in boundary using Fourier series in R and Z coordinates as,\n\nR(thetazeta) = sum_ij R_ij cos(m_jtheta - n_izeta) qquad Z(thetazeta) = sum_ij Z_ij sin(m_jtheta - n_izeta)\n\nwhere Rᵢⱼ and Zᵢⱼ are the Fourier coefficients and mⱼ and nᵢ are the Fourier modes.\n\nExample:\n\nRin = [3e-1]; Zin=[-3e-1]\nRout = [6e-1]; Zout=[-6e-1]\n\ninner = Torus(Rout,Zout,[1],[0])\nouter = Torus(Rout,Zout,[1],[0])\n\nmeshgrid(inner,outer,0.0,11,21)\n\nCoordinates at a given thetain0R and zetain02pi) can be computed using the call syntax\n\ninner(θ,ζ)\n\n\n\n\n\n","category":"type"},{"location":"tutorials/example2DCurvilinear.html#2D-on-a-circular-domain-with-parallel-map","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"","category":"section"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"For this example we will solve the head equation with a mangetic field aligned with the grid in a circular domain","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"  mathbfB = (001)","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"In this case we expect the parallel operator to do nothing since mathbfP_f=mathbfP_b=I","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"using FaADE","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"We first need to create a domain to solve the PDE using","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"nx = ny = 21;\norder = 2;\nnothing #hide","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"The interior grid will be a square,","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"g0lw = 0.25\n\nD1 = Grid2D(\n    u -> [-g0lw, -g0lw] + u * ([g0lw, -g0lw] - [-g0lw, -g0lw]),\n    v -> [-g0lw, -g0lw] + v * ([-g0lw, g0lw] - [-g0lw, -g0lw]),\n    v -> [g0lw, -g0lw] + v * ([g0lw, g0lw] - [g0lw, -g0lw]),\n    u -> [-g0lw, g0lw] + u * ([g0lw, g0lw] - [-g0lw, g0lw]),\n    nx, ny)","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"For the surrounding domains we need the shape of the circular domain. There is an inbuilt function for generating toroidal surfaces which we can use to construct the boundary curves,","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"R = 1.0\n\nTor = FaADE.Grid.Torus([R],[R],[1],[0])","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"Right domain","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"D2 = Grid2D(#u->[0.25, -u*0.5 + 0.25], # Bottom\n    u -> [g0lw, g0lw] + u * ([g0lw, -g0lw] - [g0lw, g0lw]),\n    v -> v * (Tor(π / 4, 0.0) - [g0lw, g0lw]) + [g0lw, g0lw], # Left\n    v -> v * (Tor(7π / 4, 0.0) + [-g0lw, g0lw]) + [g0lw, -g0lw], # Right\n    u -> Tor(u * (7π / 4 - 9π / 4) + 9π / 4, 0.0), # Top\n    nx, ny)","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"Top domain","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"D3 = Grid2D(#u->[u*0.5 - g0lw, g0lw], # Bottom\n    u -> [-g0lw, g0lw] + u * ([g0lw, g0lw] - [-g0lw, g0lw]),\n    v -> v * (Tor(3π / 4, 0.0) + [g0lw, -g0lw]) + [-g0lw, g0lw], # Left\n    v -> v * (Tor(π / 4, 0.0) - [g0lw, g0lw]) + [g0lw, g0lw], # Right\n    u -> Tor(u * (π / 4 - 3π / 4) + 3π / 4, 0.0), # Top\n    nx, ny)","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"Left domain","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"D4 = Grid2D(#u->[-g0lw,u*0.5 - g0lw],\n    u -> [-g0lw, -g0lw] + u * ([-g0lw, g0lw] - [-g0lw, -g0lw]),\n    v -> v * (Tor(5π / 4, 0.0) - [-g0lw, -g0lw]) + [-g0lw, -g0lw],\n    v -> v * (Tor(3π / 4, 0.0) - [-g0lw, g0lw]) + [-g0lw, g0lw],\n    u -> Tor(u * (3π / 4 - 5π / 4) + 5π / 4, 0.0),\n    nx, ny)","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"Bottom domain","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"D5 = Grid2D(#u->[-u*0.5 + g0lw, -g0lw],\n    u -> [-g0lw, -g0lw] + u * ([g0lw, -g0lw] - [-g0lw, -g0lw]),\n    v -> v * (Tor(7π / 4, 0.0) - [g0lw, -g0lw]) + [g0lw, -g0lw],\n    v -> v * (Tor(5π / 4, 0.0) - [-g0lw, -g0lw]) + [-g0lw, -g0lw],\n    u -> Tor(u * (5π / 4 - 7π / 4) + 7π / 4, 0.0),\n    nx, ny)","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"Finally, we need to tell the grid how everything is connected, this can be done by setting a tuple of boundary objects,","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"joints = ((Joint(2, Right), Joint(3, Up), Joint(4, Left), Joint(5, Down)), #Domain 1\n    (Joint(1, Down), Joint(3, Left), Joint(5, Right)), #Domain 2\n    (Joint(1, Down), Joint(4, Left), Joint(2, Right)), #Domain 3\n    (Joint(1, Down), Joint(5, Left), Joint(3, Right)), #Domain 4\n    (Joint(1, Down), Joint(2, Left), Joint(4, Right))) #Domain 5","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"We can then build the grid,","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"Dom = GridMultiBlock((D1, D2, D3, D4, D5), joints)","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"To plot the domain,","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"using Plots\n\ngridfig = plot()\nfor grid in Dom.Grids\n    scatter!(grid.gridx[:],grid.gridy[:],markersize=2)\nend\ngridfig","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"Before continuing we'll set up the boundary conditions,","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"Bxy(X, t) = 0.0\n\nDr = SAT_Dirichlet(Bxy, D2.Δy, FaADE.Up, order, D2.Δx, :Curvilinear) # Block 2 BCs\nDu = SAT_Dirichlet(Bxy, D3.Δy, FaADE.Up, order, D3.Δx, :Curvilinear) # Block 3 BCs\nDl = SAT_Dirichlet(Bxy, D4.Δy, FaADE.Up, order, D4.Δx, :Curvilinear) # Block 4 BCs\nDd = SAT_Dirichlet(Bxy, D5.Δy, FaADE.Up, order, D5.Δx, :Curvilinear) # Block 5 BCs","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"For multiblock problems we store the boundaries in a dictionary, where the key is the index for the grid,","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"BCs = Dict(2 => (Dr,), 3 => (Du,), 4 => (Dl,), 5 => (Dd,))","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"Now for setting up the parallel map, first we specifiy the magnetic field,","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"function Bfield(X, x, p, t)\n    r = x[1]^2 + x[2]^2\n\n    X[1] = 2x[2] * exp(1 - r)\n    X[2] = -2x[1] * exp(1 - r)\n\n    if (x[1] == 0.0) && (x[2] == 0.0)\n        X[1] = 0.0\n        X[2] = 0.0\n    end\nend","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"this needs to be written in the format that Julias DifferentialEquations.jl takes,","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"dH(X, x, params, t) = Bfield(X, x, params, t)","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"The field lines are defined in (stheta) space, but our grid is in Cartesian space. Therefore we need to define the coordinate maps which take us from the grid to the field coordinates and then back","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"XtoB(x, y) = [sqrt(x^2 + y^2), atan(y, x)]\nBtoX(r, θ) = [r * cos(θ), r * sin(θ)]","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"now we can construct the parallel grids,","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"gridoptions = Dict(\"xbound\" => [-10.0, 10.0], \"ybound\" => [-10.0, 10.0])\ngdata = construct_grid(dH, Dom, [-1.0, 1.0])","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"For the parallel map, we'll specify one last function called intercept, which will give the field lines a value if they leave the domain just in case,","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"intercept(u, x, y, t) = begin\n    if (sqrt(x^2 + y^2) ≈ 1.0)\n        tmp = zero(typeof(x))\n        return tmp\n    else\n        return u\n    end\nend","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"then we create a Dict of the options for the parallel map which tell the constructor to use CubicHermiteSplines for the interpolant and specify the intercept","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"interpotions = Dict(\"interpolant\" => :chs, \"intercept\" => intercept)","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"now we construct the map","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"PData = ParallelMultiBlock(gdata, Dom, order, κ=1.0, interpopts=interpotions)","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"Since we're in a circular domain with u=0 boundary conditions, we need a source term for something to happen, we'll add a circular source term","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"function F(X,t)\n    x,y = X\n    tmp = (2*(2x^2 - 1) + 2*(2y^2 - 1)) * exp(1 - (x^2 + y^2)) * (1 - exp(-2π^2*t))\n\n    tmp2 = -2π^2 * (exp(1 - (x^2 + y^2)) - 1) * exp(-2π^2*t)\n\n    return -(tmp + tmp2)\nend","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"Finally we can set the initial condition, time step and construct the Problem2D object","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"κ_perp = 1.0\n\nu₀(x, y) = 0.0\n\n\n\nΔt = 1.0e-4;\nt_f = 100Δt;\n\n\nP = Problem2D(order,u₀,κ_perp,κ_perp,Dom,BCs,source=F,parallel=PData)","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"now we can call the solver,","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"soln = solve(P,Dom,Δt,t_f)","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"Finally we can plot the solution, since it's symmetric about the origin we'll just plot a contour across the centre line,","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"fig = plot()\nplot!(Dom.Grids[1].gridx[:,11], soln.u[2][1][:,11])\nplot!(Dom.Grids[2].gridx[11,:], soln.u[2][2][11,:])\nplot!(Dom.Grids[4].gridx[11,:], soln.u[2][4][11,:])\nfig","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"","category":"page"},{"location":"tutorials/example2DCurvilinear.html","page":"2D on a circular domain with parallel map","title":"2D on a circular domain with parallel map","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/example1D.html#1D-example","page":"1D example","title":"1D example","text":"","category":"section"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"using FaADE","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"As an example we'll solve the 1D heat equation with no parallel mapping. The PDE is","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"      fracpartial upartial t = kfracpartialpartial xfracpartial upartial x","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"with boundary conditions","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"      u(0t) = 0 qquad partial_x u(1t) = 0","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"and initial condition","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"      u(x0) = expleft(frac-(x-05)^2002right)","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"We first create a domain to solve the PDE using Grid1D,","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"𝒟 = [0.0,1.0]\nn = 41\ngrid = Grid1D(𝒟,n)","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"The initial condition is a simple Gaussian","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"u₀(x) = exp.(-(x.-0.5).^2 ./ 0.02)","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"Create a few more things we'll need for the PDE and the solver such as the order (2) and the solver (conjugate gradient implicit euler)","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"order = 2;\nnothing #hide","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"The boundary conditions are defined by creating SimultanousApproximationTerm objects, which will then be fed to the PDE structure","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"BoundaryLeft = SAT_Dirichlet(t->0.0, grid.Δx, Left, order)\nBoundaryRight = SAT_Neumann(t->0.0, grid.Δx, Right, order)\n\nBCs = (BoundaryLeft, BoundaryRight)","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"We will set the diffusion coefficient to 1 eveywhere in the domain","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"K = 1.0","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"Now we can create a PDEProblem object to pass to the solver,","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"P = Problem1D(order,u₀,K,grid,BCs)","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"Lastly before solving we define our time step and simulation time,","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"Δt = 0.01grid.Δx;\nt_f = 100Δt;\nnothing #hide","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"Finally we call the solver (currently not working with Documenter.jl)","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"soln = solve(P,grid,Δt,t_f)","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"The solver outputs a solution data structure, with everything packaged in that we would need to reconstruct the problem from the final state if we wanted to restart.","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"using Plots\nplot(grid.grid, soln.u[2])","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"","category":"page"},{"location":"tutorials/example1D.html","page":"1D example","title":"1D example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Derivatives.html#Derivative-operators","page":"Derivative Operators","title":"Derivative operators","text":"","category":"section"},{"location":"Derivatives.html","page":"Derivative Operators","title":"Derivative Operators","text":"Below are the first and second derivative summation by parts operators. All stencils are written in 1D and then extended to two dimensions by looping over the required axis.","category":"page"},{"location":"Derivatives.html#FaADE.Derivatives","page":"Derivative Operators","title":"FaADE.Derivatives","text":"Derivatives\n\nModule containing first and second derivative variable coefficient SBP operators.\n\n\n\n\n\n","category":"module"},{"location":"Derivatives.html","page":"Derivative Operators","title":"Derivative Operators","text":"Derivative operators with structs belong to the abstract type.","category":"page"},{"location":"Derivatives.html#FaADE.Derivatives.DerivativeOperatorType","page":"Derivative Operators","title":"FaADE.Derivatives.DerivativeOperatorType","text":"Abstract type for derivative operators\n\n\n\n\n\n","category":"type"},{"location":"Derivatives.html#First-derivative-operators","page":"Derivative Operators","title":"First derivative operators","text":"","category":"section"},{"location":"Derivatives.html","page":"Derivative Operators","title":"Derivative Operators","text":"The below operators are for first derivatives","category":"page"},{"location":"Derivatives.html#FaADE.Derivatives.D₁","page":"Derivative Operators","title":"FaADE.Derivatives.D₁","text":"First derivative SBP operator. \n\nAlso available as and internally uses in place operator D₁!.\n\n\n\n\n\n","category":"function"},{"location":"Derivatives.html#FaADE.Derivatives.D₁!","page":"Derivative Operators","title":"FaADE.Derivatives.D₁!","text":"1D and 2D in place first derivative operator.\n\nSee also FirstDerivativeBoundary! and FirstDerivativeInternal!.\n\n\n\n\n\n","category":"function"},{"location":"Derivatives.html#FaADE.Derivatives.D₁!-Union{Tuple{AT}, Tuple{T}, Tuple{AT, AT, Integer, T, Val, T}} where {T, AT<:AbstractVector{T}}","page":"Derivative Operators","title":"FaADE.Derivatives.D₁!","text":"D₁!(uₓ::AbstractVector{T},u::AbstractVector{T},n::Integer,Δx::T,order::Integer)\n\n1D D₁!.\n\n\n\n\n\n","category":"method"},{"location":"Derivatives.html#FaADE.Derivatives.D₁!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, Integer, Integer, T, T, Int64, Int64, T}} where T","page":"Derivative Operators","title":"FaADE.Derivatives.D₁!","text":"D₁!(uₓ::AbstractArray{T},u::AbstractArray{T},nx::Integer,ny::Integer,Δx::T,Δy::T,order::Int,ordery::Int,α::T) where T\n\n2D D₁!.\n\n\n\n\n\n","category":"method"},{"location":"Derivatives.html#FaADE.Derivatives.D₁!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, Integer, T, Integer, T, Integer}} where T","page":"Derivative Operators","title":"FaADE.Derivatives.D₁!","text":"D₁!(uₓ::AbstractArray{T},u::AbstractArray{T},n::Integer,Δ::T,order::Integer,α::T,dim::Integer) where T\n\n1D implementation for 2D problems for D₁!.\n\n\n\n\n\n","category":"method"},{"location":"Derivatives.html#FaADE.Derivatives.D₁-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer, Integer, T, T}} where T","page":"Derivative Operators","title":"FaADE.Derivatives.D₁","text":"D₁(u::AbstractMatrix{T},nx::Integer,ny::Integer,Δx::T,Δy::T;order::Integer=2) where T\n\n2D implementation of D₁ operator.\n\n\n\n\n\n","category":"method"},{"location":"Derivatives.html#FaADE.Derivatives.D₁-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T","page":"Derivative Operators","title":"FaADE.Derivatives.D₁","text":"D₁(u::AbstractVector{T},Δx::T;order::Integer=2) where T\n\n1D implementation of D₁ operator.\n\njulia> n = 101\njulia> x = collect(LinRange(0.0,1.0,n))\n\njulia> u = sin.(x)\njulia> Δx = 1/(n-1)\n\njulia> D₁(u,Δx,order=2)\n\n\n\n\n\n","category":"method"},{"location":"Derivatives.html#Second-Derivative-operators","page":"Derivative Operators","title":"Second Derivative operators","text":"","category":"section"},{"location":"Derivatives.html#FaADE.Derivatives.D₂","page":"Derivative Operators","title":"FaADE.Derivatives.D₂","text":"Second derivative variable coefficient SBP operator\n\n\n\n\n\n","category":"function"},{"location":"Derivatives.html#FaADE.Derivatives.D₂!","page":"Derivative Operators","title":"FaADE.Derivatives.D₂!","text":"1D and 2D in place second derivative operator.\n\nInternally uses SecondDerivativeInternal!.\n\n\n\n\n\n","category":"function"},{"location":"Derivatives.html#FaADE.Derivatives.D₂!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, Integer, T, Val, T}} where T","page":"Derivative Operators","title":"FaADE.Derivatives.D₂!","text":"D₂!(uₓₓ::AbstractVector{T},u::AbstractVector{T},c::AbstractVector{T},n::Integer,Δx::T,order::Val,α::T) where T\n\n\n\n\n\n","category":"method"},{"location":"Derivatives.html#FaADE.Derivatives.D₂-Union{Tuple{AT}, Tuple{TT}, Tuple{AT, AT, AT, TT, TT}, Tuple{AT, AT, AT, TT, TT, Int64}} where {TT, AT<:AbstractMatrix{TT}}","page":"Derivative Operators","title":"FaADE.Derivatives.D₂","text":"Matrix version of D₂.\n\n\n\n\n\n","category":"method"},{"location":"Derivatives.html#FaADE.Derivatives.D₂-Union{Tuple{VT}, Tuple{TT}, Tuple{VT, VT, TT}, Tuple{VT, VT, TT, Int64}} where {TT, VT<:AbstractVector{TT}}","page":"Derivative Operators","title":"FaADE.Derivatives.D₂","text":"Vector version of D₂.\n\n\n\n\n\n","category":"method"},{"location":"Derivatives.html#Internals","page":"Derivative Operators","title":"Internals","text":"","category":"section"},{"location":"Derivatives.html#First-derivative-internals","page":"Derivative Operators","title":"First derivative internals","text":"","category":"section"},{"location":"Derivatives.html#FaADE.Derivatives.FirstDerivativeBoundary!","page":"Derivative Operators","title":"FaADE.Derivatives.FirstDerivativeBoundary!","text":"FirstDerivativeBoundary!\n\n1D in place function for first derivative on boundary nodes\n\n\n\n\n\n","category":"function"},{"location":"Derivatives.html#FaADE.Derivatives.FirstDerivativeBoundary!-Union{Tuple{AT}, Tuple{TT}, Tuple{AT, AT, AT, TT, FaADE.Helpers.NodeType, Val{2}, TT}} where {TT, AT<:AbstractVector{TT}}","page":"Derivative Operators","title":"FaADE.Derivatives.FirstDerivativeBoundary!","text":"FirstDerivativeBoundary!(uₓ::AT,K::AT,u::AT,Δx::TT,NT::NodeType,DO::Val{O},α::TT) where {TT,AT<:AbstractVector{TT}}\n\nu_x leftarrow alpha u_x + K d_x u\n\n\n\n\n\n","category":"method"},{"location":"Derivatives.html#FaADE.Derivatives.FirstDerivativeBoundary!-Union{Tuple{AT}, Tuple{TT}, Tuple{AT, AT, TT, FaADE.Helpers.NodeType, Val{2}, TT}} where {TT, AT<:AbstractVector{TT}}","page":"Derivative Operators","title":"FaADE.Derivatives.FirstDerivativeBoundary!","text":"FirstDerivativeBoundary!(uₓ::AT,u::AT,Δx::TT,NT::NodeType,DO::Val{O},α::TT) where {TT,AT<:AbstractVector{TT}}\n\nu_x leftarrow alpha u_x + d_x u\n\n\n\n\n\n","category":"method"},{"location":"Derivatives.html#FaADE.Derivatives.FirstDerivativeInternal","page":"Derivative Operators","title":"FaADE.Derivatives.FirstDerivativeInternal","text":"FirstDerivativeInternal(u,Δx,order,index,multiplier)\n\nSingle node 1D first derivative function. Includes 2nd, 4th and 6th order stencils.\n\n\n\n\n\n","category":"function"},{"location":"Derivatives.html#FaADE.Derivatives.FirstDerivativeInternal!","page":"Derivative Operators","title":"FaADE.Derivatives.FirstDerivativeInternal!","text":"FirstDerivativeInternal!(uₓ::AT,u::AT,Δx::T,n::Int,order::Val{O},α::T)\n\nIn place first derivative function for internal nodes.\n\n\n\n\n\n","category":"function"},{"location":"Derivatives.html#FaADE.Derivatives.FirstDerivativePeriodic-Union{Tuple{AT}, Tuple{T}, Tuple{AT, T, Val{2}, Integer, Integer, T}} where {T, AT<:AbstractVector{T}}","page":"Derivative Operators","title":"FaADE.Derivatives.FirstDerivativePeriodic","text":"FirstDerivativePeriodic\n\nSingle node 1D first derivative periodic stencil\n\n\n\n\n\n","category":"method"},{"location":"Derivatives.html#FaADE.Derivatives.FirstDerivativeTranspose!","page":"Derivative Operators","title":"FaADE.Derivatives.FirstDerivativeTranspose!","text":"FirstDerivativeTranspose!\n\nIn place 1D first derivative function\n\nTODO: Check sign on internal nodes\n\n\n\n\n\n","category":"function"},{"location":"Derivatives.html#FaADE.Derivatives.FirstDerivativeTransposeBoundary!","page":"Derivative Operators","title":"FaADE.Derivatives.FirstDerivativeTransposeBoundary!","text":"FirstDerivativeTransposeBoundary!(dest,u,Δx,NodeType,::Val{order},multiplier)\n\nIn place 1D first derivative stencil for boundary nodes\n\n\n\n\n\n","category":"function"},{"location":"Derivatives.html#Second-Derivative-internals","page":"Derivative Operators","title":"Second Derivative internals","text":"","category":"section"},{"location":"Derivatives.html#FaADE.Derivatives.SecondDerivativeBoundary!","page":"Derivative Operators","title":"FaADE.Derivatives.SecondDerivativeBoundary!","text":"SecondDerivativeBoundary!\n\nSince boundary stencils for the second derivative are not symmetric, Left and Right nodes are separate functions\n\n\n\n\n\n","category":"function"},{"location":"Derivatives.html#FaADE.Derivatives.SecondDerivativeBoundaryPeriodic!-Union{Tuple{TN}, Tuple{AT}, Tuple{TT}, Tuple{AT, AT, AT, TT, FaADE.Helpers.NodeType{TN}, Val{2}, TT}} where {TT, AT<:AbstractVector{TT}, TN}","page":"Derivative Operators","title":"FaADE.Derivatives.SecondDerivativeBoundaryPeriodic!","text":"SecondDerivativeBoundaryPeriodic!(uₓₓ::AT,u::AT,c::AT,Δx::TT,::NodeType{TN},::Val{O},α::TT) where {TT,AT<:AbstractVector{TT},TN}\n\nSecond derivative periodic stencil for boundary nodes only.\n\n\n\n\n\n","category":"method"},{"location":"Derivatives.html#FaADE.Derivatives.SecondDerivativeInternal!","page":"Derivative Operators","title":"FaADE.Derivatives.SecondDerivativeInternal!","text":"SecondDerivativeInternal!\n\nSingle node 1D second derivative function.\n\nSee also FirstDerivativeInternal! for in place multi-node functions\n\n\n\n\n\n","category":"function"},{"location":"Derivatives.html#FaADE.Derivatives.SecondDerivativeInternal!-Union{Tuple{O}, Tuple{VT}, Tuple{TT}, Tuple{VT, VT, VT, TT, Integer, Val{O}, TT}} where {TT, VT<:AbstractVector{TT}, O}","page":"Derivative Operators","title":"FaADE.Derivatives.SecondDerivativeInternal!","text":"SecondDerivativeInternal!(uₓₓ::AbstractVector{TT},u::AbstractVector{TT},cx::AbstractVector{TT},Δx::TT,nx::Integer,::Val{2},α::TT)\n\nIn place second derivative function for internal nodes.\n\n\n\n\n\n","category":"method"},{"location":"Derivatives.html#FaADE.Derivatives.SecondDerivativePeriodic","page":"Derivative Operators","title":"FaADE.Derivatives.SecondDerivativePeriodic","text":"SecondDerivativePeriodic\n\nPointwise 1D second derivative periodic stencils.\n\n\n\n\n\n","category":"function"},{"location":"Derivatives.html#FaADE.Derivatives.SecondDerivativePeriodic!-Union{Tuple{VT}, Tuple{TT}, Tuple{VT, VT, VT, TT, Val, Integer, TT}} where {TT, VT}","page":"Derivative Operators","title":"FaADE.Derivatives.SecondDerivativePeriodic!","text":"SecondDerivativePeriodic!(dest::VT,u::VT,c::VT,Δx::TT,DO::Val,n::Integer,α::TT) where {TT,VT}\n\nIn place periodic second derivative stencil.\n\n\n\n\n\n","category":"method"},{"location":"Parallel.html#Parallel-map","page":"Parallel Operator","title":"Parallel map","text":"","category":"section"},{"location":"Parallel.html","page":"Parallel Operator","title":"Parallel Operator","text":"The parallel operator for the 1D case is found here. In the 2D Cartesian case details can be found here.","category":"page"},{"location":"Parallel.html#FaADE.ParallelOperator.construct_grid-Union{Tuple{MET}, Tuple{DIM}, Tuple{TT}, Tuple{Function, GridMultiBlock{TT, DIM, MET}, Vector{TT}}} where {TT, DIM, MET}","page":"Parallel Operator","title":"FaADE.ParallelOperator.construct_grid","text":"construct_grid(χ::Function,grid::GridMultiBlock,z::Vector;interpmode=:nearest)\n\nConstructs the backwards and forward planes for a multiblock grid. Returns a dictionary of PGrid objects corresponding to the grids in GridMultiBlock.\n\nBy default will return points for nearest neighbour interpolation.\n\n\n\n\n\n","category":"method"},{"location":"Parallel.html#FaADE.ParallelOperator.construct_grid-Union{Tuple{T}, Tuple{Function, Grid2D{T, MET, GT} where {MET<:FaADE.Grid.MetricType, GT<:(AbstractArray{T})}, Vector{T}}} where T","page":"Parallel Operator","title":"FaADE.ParallelOperator.construct_grid","text":"construct_grid(χ::Function,grid::Grid2D,z::Vector)\n\nConstructs the backwards and forward planes for a given plane\n\nInputs:\n\nField line ODE that returns xy\nGridType\nz values of planes to trace to\n\nOutputs:\n\nParallelGrid object (see ParallelGrid)\n\n\n\n\n\n","category":"method"},{"location":"Parallel.html#FaADE.ParallelOperator.ParallelData","page":"Parallel Operator","title":"FaADE.ParallelOperator.ParallelData","text":"ParallelData{TT<:Real,\n    DIM,\n    TPARALLELGRID,\n    TMAGNETICFIELD,\n    TINTERPOLANT,\n    TINTERCEPT} <: ParallelGridType\n\n\n\n\n\n","category":"type"},{"location":"Parallel.html#FaADE.ParallelOperator.ParallelData-Union{Tuple{TT}, Tuple{FaADE.ParallelOperator.ParallelGrid, Grid1D{TT, MET, GT, DT} where {MET<:FaADE.Grid.MetricType, GT<:Vector{TT}, DT<:Union{Vector{TT}, Real}}, Int64}} where TT","page":"Parallel Operator","title":"FaADE.ParallelOperator.ParallelData","text":"ParallelData(PGrid::ParallelGrid,G::Grid1D{TT},order::Int;κ=TT(1),intercept=nothing) where TT\n\n\n\n\n\n","category":"method"},{"location":"Parallel.html#FaADE.ParallelOperator.ParallelData-Union{Tuple{TT}, Tuple{FaADE.ParallelOperator.ParallelGrid, Grid2D{TT, MET, GT} where {MET<:FaADE.Grid.MetricType, GT<:(AbstractArray{TT})}, Int64}} where TT","page":"Parallel Operator","title":"FaADE.ParallelOperator.ParallelData","text":"ParallelData(PGrid::ParallelGrid,G::Grid2D{TT},order::Int;κ=TT(1),intercept=nothing,B=nothing,interpolant=nothing,remap=nothing) where {TT}\n\n\n\n\n\n","category":"method"},{"location":"Parallel.html#FaADE.ParallelOperator.ParallelMultiBlock","page":"Parallel Operator","title":"FaADE.ParallelOperator.ParallelMultiBlock","text":"ParallelMultiBlock{TT,DIM,IT}\n\nStores the parallel data for multiblock problems.\n\n\n\n\n\n","category":"type"},{"location":"Parallel.html#FaADE.ParallelOperator.applyParallelPenalty!","page":"Parallel Operator","title":"FaADE.ParallelOperator.applyParallelPenalty!","text":"applyParallelPenalty!\n\nThe default generated parallel penalty function for 2D (1D+parallel) problems\n\nOperator in the 1D case is found here. In the 2D case details can be found here.    \n\n\n\n\n\n","category":"function"},{"location":"Parallel.html#FaADE.ParallelOperator.applyParallelPenalty!-Union{Tuple{DIM}, Tuple{MET}, Tuple{TT}, Tuple{AbstractArray{TT}, TT, TT, Dict{Int64, ParallelData{TT, DIM}}, Grid2D{TT, MET, GT} where GT<:(AbstractArray{TT}), Any}} where {TT, MET, DIM}","page":"Parallel Operator","title":"FaADE.ParallelOperator.applyParallelPenalty!","text":"Applies the parallel penalty for a multiblock problem\n\n\n\n\n\n","category":"method"},{"location":"Parallel.html#FaADE.ParallelOperator.applyParallelPenalty!-Union{Tuple{IT}, Tuple{BT}, Tuple{GT}, Tuple{PGT}, Tuple{MET}, Tuple{TT}, Tuple{AbstractArray{TT}, TT, TT, ParallelData{TT, 2, PGT, GT, BT, IT}, Grid2D{TT, MET, GT} where GT<:(AbstractArray{TT})}} where {TT, MET, PGT, GT, BT, IT}","page":"Parallel Operator","title":"FaADE.ParallelOperator.applyParallelPenalty!","text":"2D Parallel penalty for single block problems\n\n\n\n\n\n","category":"method"},{"location":"Parallel.html#FaADE.ParallelOperator.applyParallelPenalty!-Union{Tuple{MET}, Tuple{VT}, Tuple{TT}, Tuple{VT, TT, TT, ParallelData{TT, 1}, Grid1D{TT, MET, GT, DT} where {GT<:Vector{TT}, DT<:Union{Vector{TT}, Real}}}} where {TT, VT, MET}","page":"Parallel Operator","title":"FaADE.ParallelOperator.applyParallelPenalty!","text":"1D apply parallel penalty\n\n\n\n\n\n","category":"method"},{"location":"Parallel.html#FaADE.ParallelOperator.compute_parallel_operator-Union{Tuple{AT}, Tuple{AT, AT, ParallelData}} where AT","page":"Parallel Operator","title":"FaADE.ParallelOperator.compute_parallel_operator","text":"compute_parallel_operator\n\n\n\n\n\n","category":"method"},{"location":"Parallel.html#FaADE.ParallelOperator.computeglobalw!","page":"Parallel Operator","title":"FaADE.ParallelOperator.computeglobalw!","text":"computeglobalw!\n\n\n\n\n\n","category":"function"},{"location":"Parallel.html#FaADE.ParallelOperator.computeglobalw!-Union{Tuple{PMT}, Tuple{IT}, Tuple{BT}, Tuple{GT}, Tuple{AT}, Tuple{DIM}, Tuple{MET}, Tuple{TT}, Tuple{AbstractArray{TT}, Array{Matrix{TT}, 1}, Vector{TT}, TT, Array{ParallelData{TT, DIM, FaADE.ParallelOperator.ParallelGrid{TT, DIM, PMT, AT}, GT, BT, IT}, 1}, Grid2D{TT, MET, GT} where GT<:(AbstractArray{TT}), Any}} where {TT, MET, DIM, AT, GT, BT, IT, PMT<:FaADE.ParallelOperator.ParGrid}","page":"Parallel Operator","title":"FaADE.ParallelOperator.computeglobalw!","text":"Compute the globalw for parallel blocks where a package is used for bicubic interpolation\n\n\n\n\n\n","category":"method"},{"location":"Parallel.html#FaADE.ParallelOperator.computeglobalw!-Union{Tuple{PMT}, Tuple{IT}, Tuple{BT}, Tuple{GT}, Tuple{AT}, Tuple{DIM}, Tuple{MET}, Tuple{TT}, Tuple{METHOD}, Tuple{AbstractArray{TT}, Array{Matrix{TT}, 1}, Vector{TT}, TT, Array{ParallelData{TT, DIM, FaADE.ParallelOperator.ParallelGrid{TT, DIM, PMT, AT}, GT, BT, IT}, 1}, Grid2D{TT, MET, GT} where GT<:(AbstractArray{TT}), Any}} where {METHOD, TT, MET, DIM, AT, GT, BT, IT, PMT<:FaADE.ParallelOperator.ParGridLinear{TT, AT, METHOD}}","page":"Parallel Operator","title":"FaADE.ParallelOperator.computeglobalw!","text":"Compute the globalw for parallel blocks where a custom interpolation scheme is used\n\n\n\n\n\n","category":"method"},{"location":"Parallel.html#Internals","page":"Parallel Operator","title":"Internals","text":"","category":"section"},{"location":"Parallel.html#FaADE.ParallelOperator.ParGrid","page":"Parallel Operator","title":"FaADE.ParallelOperator.ParGrid","text":"ParGrid{TT,AT<:AbstractArray{TT}}\n\nStoring the x-y coordinates of a parallel grid\n\n\n\n\n\n","category":"type"},{"location":"Parallel.html#FaADE.ParallelOperator.ParGridLinear","page":"Parallel Operator","title":"FaADE.ParallelOperator.ParGridLinear","text":"ParGridLinear{TT,AT<:AbstractArray{TT}}\n\nStorage for a parallel map using linear interpolation.\n\n\n\n\n\n","category":"type"},{"location":"Parallel.html#FaADE.ParallelOperator.ParallelGrid","page":"Parallel Operator","title":"FaADE.ParallelOperator.ParallelGrid","text":"ParallelGrid{TT,DIM,AT,PA}\n\nStores the current, forward and backward planes for the parallel tracing.\n\nIn 2D arrays are of format (x_1y_1)(x_1y_2)(x_ny_n)\n\n\n\n\n\n","category":"type"},{"location":"Parallel.html#FaADE.ParallelOperator.ParallelGridOptions","page":"Parallel Operator","title":"FaADE.ParallelOperator.ParallelGridOptions","text":"Options for constructing the parallel grid\n\n\n\n\n\n","category":"type"},{"location":"Parallel.html#FaADE.ParallelOperator.ParallelGridType","page":"Parallel Operator","title":"FaADE.ParallelOperator.ParallelGridType","text":"ParallelGridType\n\nAbstract type for storage of \n\n\n\n\n\n","category":"type"},{"location":"Parallel.html#FaADE.ParallelOperator.ParallelMapType","page":"Parallel Operator","title":"FaADE.ParallelOperator.ParallelMapType","text":"ParallelMapType\n\n\n\n\n\n","category":"type"},{"location":"Parallel.html#FaADE.ParallelOperator.readgrid-Tuple{String}","page":"Parallel Operator","title":"FaADE.ParallelOperator.readgrid","text":"readgrid(fname::String)\n\nRead the ParallelGrid saved by savegrid into a ParallelGridType object.\n\n\n\n\n\n","category":"method"},{"location":"Parallel.html#FaADE.ParallelOperator.savegrid-Union{Tuple{PGT}, Tuple{String, PGT}} where PGT<:FaADE.ParallelOperator.ParallelGridType","page":"Parallel Operator","title":"FaADE.ParallelOperator.savegrid","text":"savegrid(fname,pargrid::ParallelGridType)\n\nSaves the ParallelGrid object containing the backward and forward plane information to a jld2 file with path and filename specified by fname.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#Solution","page":"Solution","title":"Solution","text":"","category":"section"},{"location":"solution.html#FaADE.solvers.solution","page":"Solution","title":"FaADE.solvers.solution","text":"solution\n\nSolution data structure, contains the initial condition and the solution at time of  simulation termination. Also contains the grid structure and the PDE problem that was provided  originally by the user.\n\nFields:\n\nu, grid, Δt, t, problem, Δu\n\n\n\n\n\n","category":"type"},{"location":"solution.html#FaADE.solvers.solution-Union{Tuple{TT}, Tuple{FaADE.Grid.LocalGridType{TT}, TT, TT, FaADE.Inputs.PDEProblem}} where TT","page":"Solution","title":"FaADE.solvers.solution","text":"solution{TT}(grid::LocalGridType,t::TT,Δt::TT,prob::PDEProblem) where TT\n\n\n\n\n\n","category":"method"},{"location":"solution.html#FaADE.solvers.solution-Union{Tuple{TT}, Tuple{GridMultiBlock{TT, 1}, TT, TT, FaADE.Inputs.PDEProblem}} where TT","page":"Solution","title":"FaADE.solvers.solution","text":"solution(G::GridMultiBlock{TT,1},t::TT,Δt::TT,prob::PDEProblem) where TT\n\n1 dimensional multiblock problems\n\n\n\n\n\n","category":"method"},{"location":"solution.html#FaADE.solvers.solution-Union{Tuple{TT}, Tuple{GridMultiBlock{TT, 2}, TT, TT, FaADE.Inputs.PDEProblem}} where TT","page":"Solution","title":"FaADE.solvers.solution","text":"solution(G::GridMultiBlock{TT,2},t::TT,Δt::TT,prob::PDEProblem) where TT\n\n2 dimensional multiblock problems\n\n\n\n\n\n","category":"method"},{"location":"SATs.html#Simultaneous-Approximation-Terms","page":"SATs","title":"Simultaneous Approximation Terms","text":"","category":"section"},{"location":"SATs.html#FaADE.SATs","page":"SATs","title":"FaADE.SATs","text":"SATs\n\nSubmodule containing the simulatenous approximation term constructor and functions.\n\n\n\n\n\n","category":"module"},{"location":"SATs.html","page":"SATs","title":"SATs","text":"All SATs belong to the abstract type.","category":"page"},{"location":"SATs.html#FaADE.SATs.SimultanousApproximationTerm","page":"SATs","title":"FaADE.SATs.SimultanousApproximationTerm","text":"SimultanousApproximationTerm{Type}\n\n\n\n\n\n","category":"type"},{"location":"SATs.html#Boundary-operators","page":"SATs","title":"Boundary operators","text":"","category":"section"},{"location":"SATs.html#Dirichlet","page":"SATs","title":"Dirichlet","text":"","category":"section"},{"location":"SATs.html#FaADE.SATs.SAT_Dirichlet","page":"SATs","title":"FaADE.SATs.SAT_Dirichlet","text":"SAT_Dirichlet{\n    TN<:NodeType,\n    COORD,\n    TT<:Real,\n    VT<:Vector{TT},\n    F1<:Function, LAT<:Function} <: SimultanousApproximationTerm{:Dirichlet}\n\nStorage of all objects needed for a Dirichlet SAT u(x_i) - g(t) = 0.\n\nIn Cartesian coordinates the SAT reads\n\noperatornameSAT_D = tau_0 H^-1 E H^-1 E (u - g) + tau_1 H^-1 (K H D_x^T) H^-1 E (u - g)\n\nIn Curivlinear coordinates cross derivatives are included giving\n\noperatornameSAT_D = tau_0 H_q^-1 E H_q^-1 E (u - g) + tau_1 H^-1_q ((K_q H_q D_q^T) H_q^-1 E + (K_qr H_r D_r^T) H_r^-1 E) (u - g)\n\nwhere E picks out the relevant boundary term.\n\njulia> RHS(X,t) = 0.0\njulia> Δx = 1.0\n\njulia> SAT_Dirichlet(RHS,Δx,Left,2)\n\n\n\n\n\n","category":"type"},{"location":"SATs.html#FaADE.SATs.SAT_Dirichlet-Union{Tuple{AX}, Tuple{SIDE}, Tuple{F1}, Tuple{TT}, Tuple{F1, TT, FaADE.Helpers.NodeType{SIDE, AX}, Int64}, Tuple{F1, TT, FaADE.Helpers.NodeType{SIDE, AX}, Int64, Any}, Tuple{F1, TT, FaADE.Helpers.NodeType{SIDE, AX}, Int64, Any, Any}} where {TT, F1, SIDE, AX}","page":"SATs","title":"FaADE.SATs.SAT_Dirichlet","text":"SAT_Dirichlet(RHS::F1,Δx::TT,side::NodeType{SIDE,AX},order::Int,Δy=TT(0),coord=:Cartesian;τ₀=nothing,τ₁=nothing) where {TT,F1,SIDE,AX}\n\nConstructor for the Dirichlet SAT.\n\nRequired arguments:\n\nRHS: Right hand side function\nΔx: Grid spacing\nside: Boundary side, either Left, Right, Up, Down\norder: Order of the D_x operators, either 2 or 4\n\n\n\n\n\n","category":"method"},{"location":"SATs.html#FaADE.SATs.SAT_Dirichlet_data!","page":"SATs","title":"FaADE.SATs.SAT_Dirichlet_data!","text":"Dirichlet SAT method for implicit solvers. Applys boundary data i.e. the portion of the SAT which operates on g only.\n\nAll methods wrap around the 1D method.\n\nSAT_Dirichlet_data!(dest::VT,data::VT,c::VT,SD::SAT_Dirichlet{TN}) where {VT<:AbstractVector,TN<:NodeType{SIDE}} where SIDE\n\nThe 2D method loops over the 1D method using the loopaxis value in SAT_Dirichlet.\n\nSAT_Dirichlet_data!(dest::AT,data::AT,c::AT,SD::SAT_Dirichlet{TN,:Cartesian,TT}) where {AT<:AbstractMatrix,TN<:NodeType,TT}\n\nThe curvilinear call wraps around the 1D method and then calls the FirstDerivativeTranspose! for the cross derivative term.\n\nSAT_Dirichlet_data!(dest::AT,data::AT,cx::KT,cxy::KT,SD::SAT_Dirichlet{TN,:Curvilinear,TT}) where {AT<:AbstractMatrix,TN<:NodeType,KT,TT}\n\n\n\n\n\n","category":"function"},{"location":"SATs.html#FaADE.SATs.SAT_Dirichlet_explicit!","page":"SATs","title":"FaADE.SATs.SAT_Dirichlet_explicit!","text":"SAT_Dirichlet_explicit!\n\nDirichlet SAT for explicit solvers. Currently no explicit solvers are implemented so these haven't been tested and are not used anywhere.\n\n\n\n\n\n","category":"function"},{"location":"SATs.html#FaADE.SATs.SAT_Dirichlet_solution!","page":"SATs","title":"FaADE.SATs.SAT_Dirichlet_solution!","text":"Dirichlet SAT method for implicit solvers. Applys portion of SAT related to the solution.\n\nAll methods wrap around the 1D method.\n\nSAT_Dirichlet_solution!(dest::VT,data::VT,c::VT,SD::SAT_Dirichlet{TN}) where {VT<:AbstractVector,TN<:NodeType{SIDE}} where SIDE\n\nThe 2D method loops over the 1D method using the loopaxis value in SAT_Dirichlet.\n\nSAT_Dirichlet_solution!(dest::AT,data::AT,c::KT,SD::SAT_Dirichlet{TN,:Cartesian,TT}) where {AT<:AbstractMatrix,TN<:NodeType,TT,KT}\n\nThe curvilinear call wraps around the 1D method and then calls the FirstDerivativeTranspose! for the cross derivative term.\n\nSAT_Dirichlet_solution!(dest::AT,data::AT,cx::KT,cxy::KT,SD::SAT_Dirichlet{TN,:Curvilinear,TT}) where {AT<:AbstractMatrix,TN<:NodeType,TT,KT}\n\n\n\n\n\n","category":"function"},{"location":"SATs.html#Neumann","page":"SATs","title":"Neumann","text":"","category":"section"},{"location":"SATs.html#FaADE.SATs.SAT_Neumann","page":"SATs","title":"FaADE.SATs.SAT_Neumann","text":"SAT_Neumann{\n    TN<:NodeType,\n    COORD,\n    TT<:Real,\n    VT<:Vector{TT},\n    F1<:Function, LAT<:Function} <: SimultanousApproximationTerm{:Neumann}\n\nSimulatenous approximation term for Neumann boundary conditions      leftfracpartial upartial xright_x_i = g(t) iff fracpartialpartial x u(x_i) - g(t) = 0\n\nIn Cartesian coordinates the SAT reads\n\noperatornameSAT_N = tau H^-1 E (K D_x u - g)\n\nIn curvilinear coordinates the SAT is\n\noperatornameSAT_N = tau H_x^-1 E (K_x D_x u - g) + tau H_x^-1 E K_xy D_y u\n\n\n\n\n\n","category":"type"},{"location":"SATs.html#FaADE.SATs.SAT_Neumann-Union{Tuple{AX}, Tuple{SIDE}, Tuple{F1}, Tuple{TT}, Tuple{F1, TT, FaADE.Helpers.NodeType{SIDE, AX}, Int64}, Tuple{F1, TT, FaADE.Helpers.NodeType{SIDE, AX}, Int64, Any}, Tuple{F1, TT, FaADE.Helpers.NodeType{SIDE, AX}, Int64, Any, Any}} where {TT, F1, SIDE, AX}","page":"SATs","title":"FaADE.SATs.SAT_Neumann","text":"SAT_Neumann(RHS::F1,Δx::TT,side::NodeType{SIDE,AX},order::Int,Δy=TT(0),coord=:Cartesian;τ=nothing,Δy=TT(0),coord=:Cartesian) where {TT,F1,SIDE,AX}\n\nConstructor for the Neumann SAT\n\nRequired arguments:\n\nRHS: Right hand side function\nΔx: Grid spacing\nside: Boundary side, either Left, Right, Up, Down\norder: Order of the D_x operators, either 2 or 4\n\n\n\n\n\n","category":"method"},{"location":"SATs.html#FaADE.SATs.SAT_Neumann_data!","page":"SATs","title":"FaADE.SATs.SAT_Neumann_data!","text":"Neumann SAT method for implicit solvers. Applies boundary data i.e. the portion of the SAT which operates on g only.\n\nAll methods wrap around the 1D method.\n\nSAT_Neumann_data!(dest::VT,u::VT,SN::SAT_Neumann{TN}) where {VT<:AbstractVector,TN<:NodeType{SIDE}} where SIDE\n\nThe 2D method loops over the 1D method using the loopaxis value in SAT_Neumann.\n\nSAT_Neumann_data!(dest::AT,u,SN::SAT_Neumann{TN,:Cartesian,TT}) where {AT<:AbstractMatrix,TN,TT}\n\nThe curvilinear call wraps around the 1D method.\n\nSAT_Neumann_data!(dest::AT,data::AT,SN::SAT_Neumann{TN,:Curvilinear,TT}) where {AT<:AbstractMatrix,TN<:NodeType,TT}\n\n\n\n\n\n","category":"function"},{"location":"SATs.html#FaADE.SATs.SAT_Neumann_explicit!","page":"SATs","title":"FaADE.SATs.SAT_Neumann_explicit!","text":"SAT_Neumann_explicit!\n\nNeumann boundary SAT for explicit solvers. No explicit solvers are implemented so this has not been tested and is not used.\n\n\n\n\n\n","category":"function"},{"location":"SATs.html#FaADE.SATs.SAT_Neumann_solution!","page":"SATs","title":"FaADE.SATs.SAT_Neumann_solution!","text":"Neumann SAT method for implicit solvers. Applys portion of SAT related to the solution.\n\nAll methods wrap around the 1D method.\n\nSAT_Neumann_solution!(dest::VT,u::VT,c::VT,SN::SAT_Neumann{TN}) where {VT<:AbstractVector,TN<:NodeType{SIDE}} where SIDE\n\nThe 2D method loops over the 1D method using the loopaxis value in SAT_Neumann.\n\nSAT_Neumann_solution!(dest::AT,u::AT,c::AT,SN::SAT_Neumann{TN,:Cartesian,TT}) where {AT<:AbstractMatrix,TN,TT}\n\nThe curvilinear call wraps around the 1D method. Calls the D₁! operator from FaADE.Derivatives\n\nSAT_Neumann_solution!(dest::AT,data::AT,c::AT,cxy::AT,SN::SAT_Neumann{TN,:Curvilinear,TT}) where {AT,TN<:NodeType,TT}\n\n\n\n\n\n","category":"function"},{"location":"SATs.html#Robin","page":"SATs","title":"Robin","text":"","category":"section"},{"location":"SATs.html#FaADE.SATs.SAT_Robin","page":"SATs","title":"FaADE.SATs.SAT_Robin","text":"SAT_Robin{\n        TN<:NodeType,\n        COORD,\n        TT<:Real,\n        F1<:Function, LAT<:Function} <: SimultanousApproximationTerm{:Robin}\n\nSimulatenous approximation term for Robin boundary conditions     leftalpha u(x_i) + betaleftfracpartial upartial xright_x_i - g(t) = 0\n\nIn Cartesian coordinates the SAT reads\n\noperatornameSAT_R = tau H^-1 E (alpha u + kappa D_x u - g)\n\nIn curvilinear coordinates the SAT is\n\noperatornameSAT_R = tau H^-1_q E (alpha u + K_q D_q u + K_qr D_r u - g)\n\nTODO: Testing\n\n\n\n\n\n","category":"type"},{"location":"SATs.html#FaADE.SATs.SAT_Robin-Union{Tuple{F1}, Tuple{TN}, Tuple{TT}, Tuple{AX}, Tuple{SIDE}, Tuple{F1, TT, TN, Int64}, Tuple{F1, TT, TN, Int64, Any}, Tuple{F1, TT, TN, Int64, Any, Any}} where {SIDE, AX, TT, TN<:FaADE.Helpers.NodeType{SIDE, AX}, F1}","page":"SATs","title":"FaADE.SATs.SAT_Robin","text":"SAT_Robin(RHS::F1,Δx::TT,side::TN,order::Int,Δy=TT(0),coord=:Cartesian;α=TT(1),β=TT(1),τ=nothing) where {TT,TN<:NodeType{SIDE,AX},F1} where {SIDE,AX}\n\nConstructor for Robin SAT\n\nRequired arguments:\n\nRHS: Right hand side function\nΔx: Grid spacing\nside: Boundary side, either Left, Right, Up, Down\norder: Order of the D_x operators, either 2 or 4\n\n\n\n\n\n","category":"method"},{"location":"SATs.html#FaADE.SATs.SAT_Robin_data!-Union{Tuple{TN}, Tuple{AT}, Tuple{AX}, Tuple{SIDE}, Tuple{AT, AT, SAT_Robin{TN}}} where {SIDE, AX, AT, TN<:FaADE.Helpers.NodeType{SIDE, AX}}","page":"SATs","title":"FaADE.SATs.SAT_Robin_data!","text":"Robin SAT method for implicit solvers. Applies boundary data i.e. the portion of the SAT which operates on g only.\n\nOnly one method is used for both Cartesian and curvilinear coordinates.\n\nSAT_Robin_data!(dest::AT,data::AT,SR::SAT_Robin{TN}) where {AT,TN<:NodeType{SIDE,AX}} where {SIDE,AX}\n\n\n\n\n\n","category":"method"},{"location":"SATs.html#FaADE.SATs.SAT_Robin_solution!","page":"SATs","title":"FaADE.SATs.SAT_Robin_solution!","text":"Robin SAT method for implicit solvers. Applys portion of SAT related to the solution.\n\n2D method which loops over 2D domains using the loopaxis value from SAT_Robin.\n\nSAT_Robin_solution!(dest::AT,u::AT,c::AT,SR::SAT_Robin{TN}) where {AT,TN<:NodeType{SIDE,AX}} where {SIDE,AX}\n\nThe curvilinear call wraps around the Cartesian method. Calls the D₁! operator from FaADE.Derivatives\n\nSAT_Robin_solution!(dest::AT,u::AT,c::AT,cxy::AT,SR::SAT_Robin{TN,:Curvilinear,TT}) where {TT,AT,TN}\n\n\n\n\n\n","category":"function"},{"location":"SATs.html#Periodic","page":"SATs","title":"Periodic","text":"","category":"section"},{"location":"SATs.html#FaADE.SATs.SAT_Periodic","page":"SATs","title":"FaADE.SATs.SAT_Periodic","text":"SAT_Periodic{\n    TN<:NodeType,\n    COORD,\n    TT<:Real,\n    VT<:Vector{TT},\n    F1<:Function,F2<:Function} <: SimultanousApproximationTerm{:Periodic}\n\nStorage of all objects needed for a Periodic SAT u(x_0) = u(x_N) and leftpartial_x uright_x_0 = leftpartial_x uright_x_N.\n\nIn Cartesian coordinates the SAT is\n\noperatornameSAT_P = tau_0 H^-1L_0u + tau_1 H^-1KD_x^TL_1u alpha_0 H^-1L_1KD_xu\n\nIn curvilinear coordinates the SAT is\n\noperatornameSAT_P = tau_0 H^-1L_0u + tau_1 H^-1K_qD_q^TL_1u + tau_2H^-1K_qrD_r^TL_1 u + alpha_1 H^-1L_1K_qD_qu + alpha_2 H^-1L_1K_qrD_ru\n\nwhere in both cases,\n\nL_0 = beginbmatrix 1  0  0  -1  0  0  0  0  0  0  0  0  -1  0  0  1 endbmatrix qquad\nL_1 = beginbmatrix 1  0  0  -1  0  0  0  0  0  0  0  0  1  0  0  -1 endbmatrix\n\n\n\n\n\n","category":"type"},{"location":"SATs.html#FaADE.SATs.SAT_Periodic-Union{Tuple{AX}, Tuple{SIDE}, Tuple{TT}, Tuple{TT, FaADE.Helpers.NodeType{SIDE, AX}, Int64}, Tuple{TT, FaADE.Helpers.NodeType{SIDE, AX}, Int64, Any}, Tuple{TT, FaADE.Helpers.NodeType{SIDE, AX}, Int64, Any, Any}} where {TT, SIDE, AX}","page":"SATs","title":"FaADE.SATs.SAT_Periodic","text":"SAT_Periodic(Δx::TT,side::NodeType{SIDE,AX},order::Int,Δy=TT(0),coord=:Cartesian) where {TT,SIDE,AX}\n\nConstructor for periodic SAT\n\nRequired arguments:\n\nΔx: Grid spacing\nside: Boundary side, either Left, Right, Up, Down\norder: Order of the D_x operators, either 2 or 4\n\n\n\n\n\n","category":"method"},{"location":"SATs.html#FaADE.SATs.SAT_Periodic!","page":"SATs","title":"FaADE.SATs.SAT_Periodic!","text":"Periodic SAT.\n\n1D methods for Left and Down boundaries and Right and Up boundaries respectively are\n\nSAT_Periodic!(cache::AT,u::AT,c::AT,SP::SAT_Periodic{NodeType{:Left}},::SATMode{:SolutionMode}) where {AT}\nSAT_Periodic!(cache::AT,u::AT,c::AT,SP::SAT_Periodic{NodeType{:Right}},::SATMode{:SolutionMode}) where {AT}\n\nThe 2D method loops over the 1D methods by loopaxis\n\nSAT_Periodic!(dest::AT,u::AT,c::AT,SP::SAT_Periodic{TN,:Cartesian,TT}) where {TT,AT<:AbstractMatrix{TT},TN<:NodeType}\n\nThe curvilinear method wraps the 2D Cartesian method and calls the FirstDerivativeTranspose! function.\n\nSAT_Periodic!(dest::AT,u::AT,cx::AT,cxy::AT,SP::SAT_Periodic{TN,:Curvilinear,TT}) where {TT,AT<:AbstractMatrix{TT},TN<:NodeType}\n\n\n\n\n\n","category":"function"},{"location":"SATs.html#Interface","page":"SATs","title":"Interface","text":"","category":"section"},{"location":"SATs.html#FaADE.SATs.SAT_Interface","page":"SATs","title":"FaADE.SATs.SAT_Interface","text":"SAT_Interface{\n    TN<:NodeType,\n    COORD,\n    TT<:Real,\n    TV<:Vector{TT},\n    F1<:Function} <: SimultanousApproximationTerm{:Interface}\n\nStruct for storage of the interface SAT which enforces u^-(x_I) = u^+(x_I) and leftpartial_x u^-right_x_I = leftpartial_x u^+right_x_I\n\nIn Cartesian coordinates the SAT is\n\noperatornameSAT_I = tau_0 H^-1 hatL_0 u + tau_1 H^-1 K_x D_x^T hatL_1 u + tau_2 H^-1 hatL_1 K_x D_x u\n\nand in curvilinear coordinates the SAT isnan\n\noperatornameSAT_I = tau_0 H^-1 hatL_0 u + tau_1 H^-1 (K_q D_q^T + K_qr D_r^T)hatL_1 u + tau_2 H^-1 hatL_1 (K_q D_q + K_qr D_r)u\n\nwhere in both cases\n\nhatL_0 = beginbmatrix \n    0  dots  dots  0  \n    vdots  1  -1  vdots \n    vdots  -1 1  vdots \n    0  dots  dots  0\n    endbmatrix qquad\nhatL_1 = beginbmatrix \n    0  dots  dots  0  \n    vdots  1  -1  vdots \n    vdots  1  -1  vdots \n    0  dots  dots  0\n    endbmatrix\n\n\n\n\n\n","category":"type"},{"location":"SATs.html#FaADE.SATs.SAT_Interface-Union{Tuple{AX}, Tuple{SIDE}, Tuple{AT}, Tuple{TT}, Tuple{TT, TT, AT, FaADE.Helpers.NodeType{SIDE, AX}, Int64}} where {TT, AT, SIDE, AX}","page":"SATs","title":"FaADE.SATs.SAT_Interface","text":"SAT_Interface(Δx₁::TT,Δx₂::TT,τ₀::AT,side::TN,axis::Int,order::Int;Δy=TT(0),coordinates=:Cartesian,normal=TT(1)) where {TT,AT,TN}\n\nConstructor for the interface SAT\n\nRequired arguments:\n\nΔx₁, Δx₂: Grid spacing\nτ₀: Penalty\nside: Boundary side, either Left, Right, Up, Down\norder: Order of the D_x operators, either 2 or 4\n\n\n\n\n\n","category":"method"},{"location":"SATs.html#FaADE.SATs.SAT_Interface!","page":"SATs","title":"FaADE.SATs.SAT_Interface!","text":"Applies the interface SAT where buffer contains the required data from the neighbouring block\n\nSAT_Interface!(dest::AT,u::AT,c::AT,buffer::AT,SI::SAT_Interface{TN},::SATMode{:SolutionMode}) where {AT,TN<:NodeType{:Left}}\n\nLeft handed SAT for interface conditions. Correspond to block 2 in the setup:\n\nbeginbmatrix 1  2 endbmatrix\n\nSAT_Interface!(dest::AT,u::AT,c::AT,buffer::AT,SI::SAT_Interface{TN},::SATMode{:SolutionMode}) where {AT,TN<:NodeType{:Left}}\n\nRight handed SAT for interface conditions. Correspond to block 1 in the setup:\n\nbeginbmatrix 1  2 endbmatrix\n\nSAT_Interface!(dest::AT,u::AT,c::AT,buffer::AT,SI::SAT_Interface{TN},::SATMode{:SolutionMode}) where {AT,TN<:NodeType{:Right}}\n\nThe curvilinear function calls the Cartesian functions and D₁! and FirstDerivativeTranspose! functions\n\nSAT_Interface!(dest::AT,u::AT,cx::AT,cxy::AT,buffer::AT,SI::SAT_Interface{TN,:Curvilinear,TT},::SATMode{:SolutionMode}) where {AT,TN,TT}\n\n\n\n\n\n","category":"function"},{"location":"SATs.html#FaADE.SATs.SAT_Interface_cache!","page":"SATs","title":"FaADE.SATs.SAT_Interface_cache!","text":"Writes the interface interface terms to a buffer for sending to a neighbouring block.\n\n1D and 2D Cartesian functions for Left, Down and Right, Up boundaries respectively\n\nSAT_Interface_cache!(dest::AT,u::AT,c::AT,SI::SAT_Interface{TN,COORD,TT}) where {TT,AT,COORD,TN<:NodeType{:Left}}\nSAT_Interface_cache!(dest::AT,u::AT,c::AT,SI::SAT_Interface{TN,COORD,TT}) where {TT,AT,COORD,TN<:NodeType{:Right}}\n\nFor curvilinear coordinates the D₁! operator is used from FaADE.Derivatives\n\nSAT_Interface_cache!(dest::AT,u::AT,c::AT,cxy::AT,SI::SAT_Interface{TN,:Curvilinear,TT}) where {TT,AT,TN}\n\n\n\n\n\n","category":"function"},{"location":"SATs.html","page":"SATs","title":"SATs","text":"","category":"page"},{"location":"SATs.html#Helpers","page":"SATs","title":"Helpers","text":"","category":"section"},{"location":"SATs.html#FaADE.SATs.SATMode","page":"SATs","title":"FaADE.SATs.SATMode","text":"SATMode{T}\n\nUsed with the conjugate gradient solver so the appropriate function call can be used.\n\nValues are \n\nDataMode for applying boundary data,\nSolutionMode for applying the term which only includes u such as u-g in Dirichlet conditions,\nExplicitMode currently no solver implemented uses this.\n\n\n\n\n\n","category":"type"},{"location":"index.html#FaADE.jl","page":"Home","title":"FaADE.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A Summation by Parts code for solving the field aligned Anisotropic Diffusion Equation. ","category":"page"},{"location":"index.html#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"FaADE.jl is a code for solving the field aligned anisotropic diffusion equation","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"fracpartial upartial t = nablacdot(mathbfK nabla ) u","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"where","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"mathbfK = k_perpmathbfI + (k_parallel - k_perp)fracmathbfBmathbfB^TmathbfB^2","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Uses the Summation by Parts formulation with Simultaneous Approximation Terms (SBP-SAT) for boundary conditions [1].\nParallel penalty operator used to apply diffusion along vector field lines.\nCurrently arbitrary parallel mappings can be provided in Cartesian geometry or an ODE for mapping grid points along field lines.\nProvides solutions in 1D for:\ndiffusion problems\nwith a parallel map in the second dimension\nand solutions in 2D for:\ndiffusion problems\nwith a parallel map in the third dimension","category":"page"},{"location":"index.html#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The best place to start is in the Examples section in the navigation bar to the left.","category":"page"},{"location":"index.html#Modules","page":"Home","title":"Modules","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\"SATs.md\",\"Derivatives.md\",\"Helpers.md\",\"solvers.md\"]\nDepth=2","category":"page"},{"location":"index.html#Similar-software","page":"Home","title":"Similar software","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"SummationByParts.jl: A Julia implementation of a wide range of SBP operators\npyoculus: A magnetic field diagnostic package in python based on an earlier FORTRAN implementation oculus","category":"page"},{"location":"index.html#References","page":"Home","title":"References","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The mathematical background for this package can be found in:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"D. Muir, K. Duru, M. Hole, and S. Hudson, “An efficient method for the anisotropic diffusion equation in magnetic fields,” Feb. 08, 2023, arXiv. doi: 10.48550/arXiv.2303.15447.\nD. Muir, K. Duru, M. Hole, and S. Hudson, “A provably stable numerical method for the anisotropic diffusion equation in confined magnetic fields,” Apr. 09, 2024, arXiv. doi: 10.48550/arXiv.2306.00423.","category":"page"}]
}
